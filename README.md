### 背景
主要总结面试经常遇到的问题，方便复习，代码都很简单，很适合速食，突击面试，加油！
#### 设计模式
##### 创建型
###### 单例模式
- 场景：spring创建对象
- 优点：单例保证资源复用
- 缺点：修改对象的属性值，例如接口调用
- 设置：通过注解可设置为多例scope="prototype"
- 创建方式：双重锁检查，静态内部类，枚举形式创建
- spring创建的所有类，默认都是单例

###### 工厂模式
- 描述：创建不同对象时，不用new直接创建，而交给一个工厂进行统一创建
- 场景：spring创建对象
- 优点：降低系统耦合性
- 工厂类型：简单工厂，抽象工厂，工厂方法
- 使用：通常结合自定义注解（@Interface）和枚举类，自定义工厂类实现ApplicationContextAware（可以顺带复习下生命周期），在spring启动时根据映射关系自动创建相应的对象
- spring的beanFactory

##### 行为型
###### 模板方法模式
- 描述：父类定义方法，并在前后设置before和after抽象方法。子类继承父类，重写before和after方法。
- 场景：spring的ioc流程，注册并解析beanDefinitions前后
- 优点：方便不影响原逻辑基础上进行扩展
- 使用：比如给用户进行授权，授权前发送短信，授权后通知其他服务
- 父类定义框架和主要逻辑，父类进行一个扩展

###### 责任链

- 描述：处理一系列复杂业务流程，通过责任链将流程进行串联
- 约束：需要严格控制先后顺序
- 场景：当SpringAop增强通知其已经注入到IOC容器中，创建Aop对象前，会将通知对象其放入通知链中。当调用代理类的invoker方法时，获取通知链，匹配条件后，通过适配器转成拦截链，拦截springAop定义的切面中的方法
- 优点：避免代码耦合，让多个对象都有机会处理该方法
- filter

###### 策略模式

- 描述：定义一套动作，然后具体的方案给子类实现
- 约束：所有策略都是同一个动作
- 场景：比如化妆品促销（接口），满2000送样品（动作），满3000送购物卡（动作），组织一个活动（context）依赖促销，通过传入来进行活动
- 优点：避免代码耦合，定义一个方法，具体的实现交给子类
- 必须：同一行为的不同方案
- Arrays.sort参数Comparator

###### 观察者模式



##### 结构型
###### 装饰器模式
- 举例：抽象类（炒蔬菜A），两个实现类（炒白菜A1，炒胡萝卜A2）；装饰器类依赖A（炒肉A3），实现类（炒牛肉A4）；A4类的构造器派生父类A，A4 a4(A)，可将A1和A2传入A4。
- 场景：InputStream抽象类，FilterInputStream装饰类，BufferedInputStream和GZIPInputStream子类
- 优点：动态的给子类添加部分功能
- InputStream BufferedInputStream DataInputStream

###### 代理模式
- 优点：通过代理对原有的类进行加强
- 场景：RPC框架的服务调用层、Spring AOP的通知增强
- 类型：
  - 静态代理：
    - 方式：接口A，实现类B，代理类C实现接口A，并且依赖实现类C
  - 缺点：不够灵活
  - 动态代理：
    - Jdk动态代理（基于接口，实现InvocationHandler，覆盖invoke方法）
    - CgLib动态代理（基于具体的类)
- 被final修饰无法代理

###### 适配器模式
- 举例：接口（大陆插座），实现类（大陆插头）；接口（香港插头）依赖大陆插座用大陆插头进行装饰，实现类（香港手机）；香港手机想在大陆充电。
- 场景：InputStream抽象类，FilterInputStream装饰类，BufferedInputStream和GZIPInputStream子类
- 优点：动态的给子类添加部分功能


本文仅供学习，内容参考以下